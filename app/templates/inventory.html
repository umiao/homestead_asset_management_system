{% extends "base.html" %}

{% block title %}Inventory - PantryPilot{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="/static/css/autocomplete.css">
<style>
    /* Hide checkboxes by default */
    .table tbody td:first-child {
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
    }

    /* Keep header checkbox always visible */
    .table thead th:first-child {
        opacity: 1;
    }

    /* Show checkbox only on specific row hover */
    .table tbody tr:hover td:first-child {
        opacity: 1;
    }

    /* Also show checkboxes when any checkbox is checked */
    .table.has-selections tbody td:first-child {
        opacity: 1;
    }

    /* Hide action buttons by default */
    .table tbody td:last-child {
        opacity: 0;
        transition: opacity 0.2s ease-in-out;
    }

    /* Keep the header visible */
    .table thead th:last-child {
        opacity: 1;
    }

    /* Show action buttons only on specific row hover */
    .table tbody tr:hover td:last-child {
        opacity: 1;
    }

    /* Sortable column headers */
    .sortable {
        cursor: pointer;
        user-select: none;
        position: relative;
        padding-right: 20px;
    }

    .sortable:hover {
        background-color: rgba(0, 0, 0, 0.05);
    }

    .sortable::after {
        content: '⇅';
        position: absolute;
        right: 5px;
        opacity: 0.3;
        font-size: 0.8rem;
    }

    .sortable.asc::after {
        content: '↑';
        opacity: 1;
    }

    .sortable.desc::after {
        content: '↓';
        opacity: 1;
    }

    /* Location tree independent scrolling */
    #location-tree {
        max-height: calc(100vh - 250px); /* Viewport height minus header and margins */
        overflow-y: auto;
        overflow-x: hidden;
        padding-right: 5px;
    }

    /* Custom scrollbar for location tree */
    #location-tree::-webkit-scrollbar {
        width: 8px;
    }

    #location-tree::-webkit-scrollbar-track {
        background: var(--light-bg, #f1f1f1);
        border-radius: 4px;
    }

    #location-tree::-webkit-scrollbar-thumb {
        background: var(--border-color, #ccc);
        border-radius: 4px;
    }

    #location-tree::-webkit-scrollbar-thumb:hover {
        background: var(--text-secondary, #999);
    }

    /* Selected location highlight */
    .tree-node.selected {
        background-color: var(--primary-color, #0ea5e9) !important;
        color: white !important;
    }

    .tree-node.selected .tree-count {
        background-color: rgba(255, 255, 255, 0.3);
        color: white;
    }
</style>
{% endblock %}

{% block content %}
<h1 style="margin-bottom: 2rem; font-size: 2rem; font-weight: 700;">Inventory Management</h1>

<!-- Search and Filters -->
<div class="card">
    <div class="search-bar">
        <input type="text" id="search-input" class="search-input" placeholder="Search items...">
        <select id="category-filter" class="form-select" style="width: 200px;">
            <option value="">All Categories</option>
        </select>
        <select id="expiry-filter" class="form-select" style="width: 200px;">
            <option value="">All Status</option>
            <option value="fresh">Fresh</option>
            <option value="expiring_soon">Expiring Soon</option>
            <option value="expired">Expired</option>
            <option value="no_expiry">No Expiry</option>
            <option value="n/a">N/A (Non-Food)</option>
        </select>
        <button onclick="searchItems()" class="btn btn-primary">
            <i data-lucide="search" class="icon"></i>
            Search
        </button>
        <button onclick="showAddModal()" class="btn btn-success">
            <i data-lucide="plus-circle" class="icon"></i>
            Add Item
        </button>
        <button onclick="deleteSelected()" class="btn btn-danger" id="delete-selected-btn" style="display: none;">
            <i data-lucide="trash-2" class="icon"></i>
            Delete Selected (<span id="selected-count">0</span>)
        </button>
    </div>
</div>

<!-- Two Column Layout -->
<div style="display: grid; grid-template-columns: 300px 1fr; gap: 1.5rem;">
    <!-- Location Hierarchy Sidebar -->
    <div class="card" style="height: fit-content; position: sticky; top: 100px;">
        <div class="card-header">
            <h3 class="card-title">Locations</h3>
        </div>
        <div id="location-tree">
            <div class="spinner"></div>
        </div>
    </div>

    <!-- Items List -->
    <div class="card">
        <div class="card-header">
            <h3 class="card-title">Items</h3>
            <span id="item-count" style="color: var(--text-secondary);">0 items</span>
        </div>
        <div id="items-container">
            <div class="spinner"></div>
        </div>
    </div>
</div>

<!-- Add/Edit Item Modal -->
<div id="item-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
    <div class="card" style="max-width: 600px; width: 90%; margin: 2rem; max-height: 90vh; overflow-y: auto;">
        <div class="card-header">
            <h3 class="card-title" id="modal-title">Add New Item</h3>
            <button onclick="closeModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">×</button>
        </div>
        <form id="item-form" onsubmit="saveItem(event)">
            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Name * <span style="font-size: 0.75rem; color: var(--text-secondary); font-weight: normal;">(支持逗号分隔批量添加 / comma-separated for bulk add)</span></label>
                    <input type="text" id="item-name" class="form-input" placeholder="e.g., Apple, Orange, Banana or 苹果，橙子，香蕉" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Category *</label>
                    <input type="text" id="item-category" class="form-input" autocomplete="off" required>
                </div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Quantity *</label>
                    <input type="number" id="item-quantity" class="form-input" step="0.01" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Unit *</label>
                    <input type="text" id="item-unit" class="form-input" autocomplete="off" placeholder="e.g., count, kg, liter" required>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Location Path *</label>
                <input type="text" id="item-location" class="form-input" autocomplete="off" placeholder="e.g., Kitchen > Fridge > Top Shelf" required>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Acquired Date</label>
                    <input type="date" id="item-acquired" class="form-input">
                </div>
                <div class="form-group">
                    <label class="form-label">Expiry Date</label>
                    <input type="date" id="item-expiry" class="form-input">
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Notes</label>
                <textarea id="item-notes" class="form-textarea" rows="3"></textarea>
            </div>

            <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                <button type="button" onclick="closeModal()" class="btn btn-secondary">Cancel</button>
                <button type="submit" class="btn btn-primary">Save Item</button>
            </div>
        </form>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center;">
    <div class="card" style="max-width: 500px; width: 90%; margin: 2rem;">
        <div class="card-header">
            <h3 class="card-title">出库确认 / Checkout Confirmation</h3>
            <button onclick="closeDeleteModal()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">×</button>
        </div>
        <form id="delete-form" onsubmit="confirmDelete(event)">
            <div id="delete-items-list" style="margin-bottom: 1rem; padding: 1rem; background-color: var(--light-bg); border-radius: 0.5rem;">
                <!-- Item list will be populated here -->
            </div>

            <div class="form-group">
                <label class="form-label">出库原因 / Reason for Removal *</label>
                <select id="delete-reason" class="form-select" required onchange="toggleCustomReason()">
                    <option value="">请选择 / Please select</option>
                    <option value="已消耗 / Consumed">已消耗 / Consumed</option>
                    <option value="过期丢弃 / Expired">过期丢弃 / Expired</option>
                    <option value="损坏 / Damaged">损坏 / Damaged</option>
                    <option value="转移 / Transferred">转移 / Transferred</option>
                    <option value="捐赠 / Donated">捐赠 / Donated</option>
                    <option value="其他 / Other">其他 / Other</option>
                </select>
            </div>

            <div class="form-group" id="custom-reason-group" style="display: none;">
                <label class="form-label">请说明 / Please specify</label>
                <input type="text" id="custom-reason" class="form-input">
            </div>

            <div class="form-group">
                <label class="form-label">出库记录 / Checkout Record (可选 / Optional)</label>
                <textarea id="checkout-record" class="form-textarea" rows="3" placeholder="例如: 用于晚餐烹饪 / E.g., Used for dinner cooking"></textarea>
            </div>

            <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                <button type="button" onclick="closeDeleteModal()" class="btn btn-secondary">取消 / Cancel</button>
                <button type="submit" class="btn btn-danger">确认删除 / Confirm Delete</button>
            </div>
        </form>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    let allItems = [];
    let allLocations = [];
    let selectedLocationId = null;
    let itemsToDelete = []; // Track items pending deletion
    let editingItemId = null; // Track item being edited
    let currentDisplayedItems = []; // Track currently displayed items
    let sortState = {
        acquired: null, // null, 'asc', or 'desc'
        expiry: null
    };
    let filterState = {
        query: '',
        category: '',
        expiryStatus: ''
    };

    async function loadInventory() {
        try {
            // Load items
            allItems = await fetchAPI('/inventory/items?limit=1000');

            // Load locations
            allLocations = await fetchAPI('/inventory/locations');

            // Load categories
            const categories = await fetchAPI('/inventory/categories');
            populateCategoryFilter(categories);
            // Note: Category datalist removed - now using LFU autocomplete

            // Restore filter state to UI
            document.getElementById('search-input').value = filterState.query;
            document.getElementById('category-filter').value = filterState.category;
            document.getElementById('expiry-filter').value = filterState.expiryStatus;

            // Display
            displayLocationTree(allLocations);

            // Restore location selection or apply filters
            if (selectedLocationId) {
                // Re-select the same location
                selectLocation(selectedLocationId);
            } else {
                // Apply saved filters and sorting
                searchItems();
            }

        } catch (error) {
            console.error('Error loading inventory:', error);
            showMessage('Error loading inventory', 'error');
        }
    }

    function populateCategoryFilter(categories) {
        const select = document.getElementById('category-filter');
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = cat;
            select.appendChild(option);
        });
    }

    // populateCategoryDatalist() removed - replaced by LFU autocomplete

    function displayLocationTree(locations) {
        const container = document.getElementById('location-tree');

        if (locations.length === 0) {
            container.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.875rem;">No locations yet</p>';
            return;
        }

        // Build tree structure
        const locationMap = {};
        const rootLocations = [];

        locations.forEach(loc => {
            locationMap[loc.id] = { ...loc, children: [] };
        });

        locations.forEach(loc => {
            if (loc.parent_id) {
                if (locationMap[loc.parent_id]) {
                    locationMap[loc.parent_id].children.push(locationMap[loc.id]);
                }
            } else {
                rootLocations.push(locationMap[loc.id]);
            }
        });

        // Render tree
        container.innerHTML = '<ul class="tree">' + renderLocationNodes(rootLocations) + '</ul>';

        // Reinitialize lucide icons
        lucide.createIcons();
    }

    function renderLocationNodes(nodes) {
        return nodes.map(node => {
            const itemCount = allItems.filter(item => item.location_id === node.id).length;
            const hasChildren = node.children && node.children.length > 0;
            const isSelected = selectedLocationId === node.id;

            return `
                <li class="tree-item">
                    <div class="tree-node ${isSelected ? 'selected' : ''}" onclick="selectLocation(${node.id})" data-location-id="${node.id}">
                        <span class="tree-icon">
                            <i data-lucide="${hasChildren ? 'folder' : 'folder-open'}" style="width: 18px; height: 18px;"></i>
                        </span>
                        <span class="tree-label">${node.name}</span>
                        ${itemCount > 0 ? `<span class="tree-count">${itemCount}</span>` : ''}
                    </div>
                    ${hasChildren ? '<ul class="tree-children">' + renderLocationNodes(node.children) + '</ul>' : ''}
                </li>
            `;
        }).join('');
    }

    function updateLocationHighlight() {
        // Remove all previous selections
        document.querySelectorAll('.tree-node').forEach(node => {
            node.classList.remove('selected');
        });

        // Highlight the selected location
        if (selectedLocationId) {
            const selectedNode = document.querySelector(`.tree-node[data-location-id="${selectedLocationId}"]`);
            if (selectedNode) {
                selectedNode.classList.add('selected');
            }
        }
    }

    function selectLocation(locationId) {
        selectedLocationId = locationId;
        const filtered = allItems.filter(item => item.location_id === locationId);

        // Apply saved sort state if any
        const activeSortColumn = sortState.acquired ? 'acquired' : (sortState.expiry ? 'expiry' : null);
        if (activeSortColumn) {
            filtered.sort((a, b) => {
                const dateA = activeSortColumn === 'acquired' ? a.acquired_date : a.expiry_date;
                const dateB = activeSortColumn === 'acquired' ? b.acquired_date : b.expiry_date;

                // Handle null dates (put them at the end)
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;

                const dateObjA = new Date(dateA);
                const dateObjB = new Date(dateB);

                // Primary sort by the selected date column
                let comparison = 0;
                if (sortState[activeSortColumn] === 'desc') {
                    comparison = dateObjB - dateObjA; // Newest first
                } else {
                    comparison = dateObjA - dateObjB; // Oldest first
                }

                // If dates are equal, use updated_at as tie-breaker (most recently updated first)
                if (comparison === 0) {
                    const updatedA = new Date(a.updated_at || a.created_at);
                    const updatedB = new Date(b.updated_at || b.created_at);
                    return updatedB - updatedA; // Most recently updated first
                }

                return comparison;
            });
        }

        displayItems(filtered);
        updateSortIndicators();
        updateLocationHighlight();
    }

    function searchItems() {
        const query = document.getElementById('search-input').value.toLowerCase();
        const category = document.getElementById('category-filter').value;
        const expiryStatus = document.getElementById('expiry-filter').value;

        // Save filter state
        filterState.query = query;
        filterState.category = category;
        filterState.expiryStatus = expiryStatus;

        let filtered = allItems;

        if (query) {
            filtered = filtered.filter(item =>
                item.name.toLowerCase().includes(query) ||
                (item.notes && item.notes.toLowerCase().includes(query))
            );
        }

        if (category) {
            filtered = filtered.filter(item => item.category === category);
        }

        if (expiryStatus) {
            filtered = filtered.filter(item => item.expiry_status === expiryStatus);
        }

        // Apply saved sort state if any
        const activeSortColumn = sortState.acquired ? 'acquired' : (sortState.expiry ? 'expiry' : null);
        if (activeSortColumn) {
            filtered.sort((a, b) => {
                const dateA = activeSortColumn === 'acquired' ? a.acquired_date : a.expiry_date;
                const dateB = activeSortColumn === 'acquired' ? b.acquired_date : b.expiry_date;

                // Handle null dates (put them at the end)
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;

                const dateObjA = new Date(dateA);
                const dateObjB = new Date(dateB);

                // Primary sort by the selected date column
                let comparison = 0;
                if (sortState[activeSortColumn] === 'desc') {
                    comparison = dateObjB - dateObjA; // Newest first
                } else {
                    comparison = dateObjA - dateObjB; // Oldest first
                }

                // If dates are equal, use updated_at as tie-breaker (most recently updated first)
                if (comparison === 0) {
                    const updatedA = new Date(a.updated_at || a.created_at);
                    const updatedB = new Date(b.updated_at || b.created_at);
                    return updatedB - updatedA; // Most recently updated first
                }

                return comparison;
            });
        }

        displayItems(filtered);
        updateSortIndicators();
    }

    function displayItems(items) {
        const container = document.getElementById('items-container');
        document.getElementById('item-count').textContent = `${items.length} items`;

        // Store currently displayed items for sorting
        currentDisplayedItems = [...items];

        if (items.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">
                        <i data-lucide="package" style="width: 64px; height: 64px;"></i>
                    </div>
                    <div class="empty-state-title">No items found</div>
                    <p>Try adjusting your filters or add new items</p>
                </div>
            `;
            lucide.createIcons();
            return;
        }

        const table = `
            <div class="table-container">
                <table class="table">
                    <thead>
                        <tr>
                            <th style="width: 40px;">
                                <input type="checkbox" id="select-all" onchange="toggleSelectAll(this)">
                            </th>
                            <th>Name</th>
                            <th>Category</th>
                            <th>Quantity</th>
                            <th>Location</th>
                            <th class="sortable" onclick="sortByDate('acquired')" id="acquired-header">Acquired</th>
                            <th class="sortable" onclick="sortByDate('expiry')" id="expiry-header">Expiry</th>
                            <th>Status</th>
                            <th class="actions-column">Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${items.map(item => {
                            const location = allLocations.find(loc => loc.id === item.location_id);
                            const hasNotes = item.notes && item.notes.trim().length > 0;
                            const notesTitle = hasNotes ? item.notes.replace(/"/g, '&quot;') : '';
                            const nameStyle = hasNotes
                                ? 'font-weight: 600; cursor: help; text-decoration: underline dotted; text-decoration-color: var(--border-color);'
                                : 'font-weight: 600;';
                            return `
                                <tr class="hoverable-row">
                                    <td>
                                        <input type="checkbox" class="item-checkbox" value="${item.id}" onchange="updateSelectedCount()">
                                    </td>
                                    <td style="${nameStyle}" ${hasNotes ? `title="${notesTitle}"` : ''}>
                                        ${item.name}
                                    </td>
                                    <td>${item.category}</td>
                                    <td>${item.quantity} ${item.unit}</td>
                                    <td style="font-size: 0.875rem;">${location ? location.full_path : 'Unknown'}</td>
                                    <td style="font-size: 0.875rem;">${formatDate(item.acquired_date)}</td>
                                    <td style="font-size: 0.875rem;">${formatDate(item.expiry_date)}</td>
                                    <td>
                                        <span class="badge ${getExpiryBadge(item.expiry_status)}">
                                            ${getExpiryLabel(item.expiry_status)}
                                        </span>
                                    </td>
                                    <td class="action-buttons">
                                        <button onclick="editItem(${item.id})" class="btn btn-primary btn-sm" style="margin-right: 0.5rem;">Edit</button>
                                        <button onclick="deleteItem(${item.id})" class="btn btn-danger btn-sm">Delete</button>
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            </div>
        `;
        container.innerHTML = table;
        updateSelectedCount();

        // Restore sort indicators
        updateSortIndicators();
    }

    function sortByDate(column) {
        // Determine next sort state: null -> desc -> asc -> null
        if (sortState[column] === null) {
            sortState[column] = 'desc';
        } else if (sortState[column] === 'desc') {
            sortState[column] = 'asc';
        } else {
            sortState[column] = null;
        }

        // Reset other column's sort state
        const otherColumn = column === 'acquired' ? 'expiry' : 'acquired';
        sortState[otherColumn] = null;

        // Sort the items
        const sortedItems = [...currentDisplayedItems];

        if (sortState[column] !== null) {
            sortedItems.sort((a, b) => {
                const dateA = column === 'acquired' ? a.acquired_date : a.expiry_date;
                const dateB = column === 'acquired' ? b.acquired_date : b.expiry_date;

                // Handle null dates (put them at the end)
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;

                const dateObjA = new Date(dateA);
                const dateObjB = new Date(dateB);

                // Primary sort by the selected date column
                let comparison = 0;
                if (sortState[column] === 'desc') {
                    comparison = dateObjB - dateObjA; // Newest first
                } else {
                    comparison = dateObjA - dateObjB; // Oldest first
                }

                // If dates are equal, use updated_at as tie-breaker (most recently updated first)
                if (comparison === 0) {
                    const updatedA = new Date(a.updated_at || a.created_at);
                    const updatedB = new Date(b.updated_at || b.created_at);
                    return updatedB - updatedA; // Most recently updated first
                }

                return comparison;
            });
        }

        // Re-display with sorted items
        displayItems(sortedItems);
    }

    function updateSortIndicators() {
        // Update header classes
        const acquiredHeader = document.getElementById('acquired-header');
        const expiryHeader = document.getElementById('expiry-header');

        if (acquiredHeader) {
            acquiredHeader.className = 'sortable';
            if (sortState.acquired) {
                acquiredHeader.classList.add(sortState.acquired);
            }
        }

        if (expiryHeader) {
            expiryHeader.className = 'sortable';
            if (sortState.expiry) {
                expiryHeader.classList.add(sortState.expiry);
            }
        }
    }

    // Track if autocomplete has been initialized
    let autocompleteInitialized = false;

    function showAddModal() {
        editingItemId = null;
        document.getElementById('item-modal').style.display = 'flex';
        document.getElementById('modal-title').textContent = 'Add New Item';
        document.getElementById('item-form').reset();

        // Set default acquired date to today
        document.getElementById('item-acquired').valueAsDate = new Date();

        // Initialize autocomplete on first modal open
        if (!autocompleteInitialized && typeof initAutocomplete === 'function') {
            initializeAutocomplete();
            autocompleteInitialized = true;
        }
    }

    function editItem(itemId) {
        const item = allItems.find(i => i.id === itemId);
        if (!item) {
            showMessage('Item not found', 'error');
            return;
        }

        editingItemId = itemId;
        document.getElementById('item-modal').style.display = 'flex';
        document.getElementById('modal-title').textContent = 'Edit Item';

        // Populate form with existing data
        document.getElementById('item-name').value = item.name;
        document.getElementById('item-category').value = item.category;
        document.getElementById('item-quantity').value = item.quantity;
        document.getElementById('item-unit').value = item.unit;

        const location = allLocations.find(loc => loc.id === item.location_id);
        document.getElementById('item-location').value = location ? location.full_path : '';

        document.getElementById('item-acquired').value = item.acquired_date || '';
        document.getElementById('item-expiry').value = item.expiry_date || '';
        document.getElementById('item-notes').value = item.notes || '';
    }

    function closeModal() {
        document.getElementById('item-modal').style.display = 'none';
        editingItemId = null;
    }

    async function saveItem(event) {
        event.preventDefault();

        const formData = {
            name: document.getElementById('item-name').value,
            category: document.getElementById('item-category').value,
            quantity: parseFloat(document.getElementById('item-quantity').value),
            unit: document.getElementById('item-unit').value,
            location_path: document.getElementById('item-location').value,
            acquired_date: document.getElementById('item-acquired').value || null,
            expiry_date: document.getElementById('item-expiry').value || null,
            notes: document.getElementById('item-notes').value || null
        };

        try {
            if (editingItemId) {
                // Update existing item
                await fetchAPI(`/inventory/items/${editingItemId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });
                showMessage('Item updated successfully', 'success');
            } else {
                // Create new item(s)
                const result = await fetchAPI('/inventory/items', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });

                // Check if multiple items were created
                if (result.count && result.count > 1) {
                    showMessage(`Successfully created ${result.count} items`, 'success');
                } else {
                    showMessage('Item added successfully', 'success');
                }
            }

            closeModal();
            loadInventory();
        } catch (error) {
            console.error('Error saving item:', error);
            showMessage(`Error ${editingItemId ? 'updating' : 'saving'} item`, 'error');
        }
    }

    function toggleSelectAll(checkbox) {
        const checkboxes = document.querySelectorAll('.item-checkbox');
        checkboxes.forEach(cb => cb.checked = checkbox.checked);
        updateSelectedCount();
    }

    function updateSelectedCount() {
        const checkboxes = document.querySelectorAll('.item-checkbox:checked');
        const count = checkboxes.length;
        document.getElementById('selected-count').textContent = count;

        const deleteBtn = document.getElementById('delete-selected-btn');
        if (count > 0) {
            deleteBtn.style.display = 'inline-flex';
        } else {
            deleteBtn.style.display = 'none';
        }

        // Update select-all checkbox state
        const allCheckboxes = document.querySelectorAll('.item-checkbox');
        const selectAllCheckbox = document.getElementById('select-all');
        if (selectAllCheckbox && allCheckboxes.length > 0) {
            selectAllCheckbox.checked = count === allCheckboxes.length;
        }

        // Toggle has-selections class to keep checkboxes visible when items are selected
        const table = document.querySelector('.table');
        if (table) {
            if (count > 0) {
                table.classList.add('has-selections');
            } else {
                table.classList.remove('has-selections');
            }
        }
    }

    function deleteSelected() {
        const checkboxes = document.querySelectorAll('.item-checkbox:checked');
        const itemIds = Array.from(checkboxes).map(cb => parseInt(cb.value));

        if (itemIds.length === 0) {
            showMessage('No items selected', 'error');
            return;
        }

        // Get items to delete
        itemsToDelete = allItems.filter(item => itemIds.includes(item.id));
        showDeleteModal();
    }

    function deleteItem(itemId) {
        // Get the item
        const item = allItems.find(i => i.id === itemId);
        if (!item) {
            showMessage('Item not found', 'error');
            return;
        }

        itemsToDelete = [item];
        showDeleteModal();
    }

    function showDeleteModal() {
        const modal = document.getElementById('delete-modal');
        const itemsList = document.getElementById('delete-items-list');

        // Display items to be deleted with scrollable container
        itemsList.innerHTML = `
            <strong>待删除物品 / Items to Delete (${itemsToDelete.length}):</strong>
            <div style="max-height: 200px; overflow-y: auto; margin-top: 0.5rem; border: 1px solid var(--border-color); border-radius: 0.375rem; padding: 0.5rem;">
                <ul style="margin: 0; padding-left: 1.5rem;">
                    ${itemsToDelete.map(item => `
                        <li style="padding: 0.25rem 0;">${item.name} - ${item.quantity} ${item.unit}</li>
                    `).join('')}
                </ul>
            </div>
        `;

        modal.style.display = 'flex';
    }

    function closeDeleteModal() {
        const modal = document.getElementById('delete-modal');
        modal.style.display = 'none';

        // Reset form
        document.getElementById('delete-form').reset();
        document.getElementById('custom-reason-group').style.display = 'none';
        itemsToDelete = [];
    }

    function toggleCustomReason() {
        const reasonSelect = document.getElementById('delete-reason');
        const customReasonGroup = document.getElementById('custom-reason-group');
        const customReasonInput = document.getElementById('custom-reason');

        if (reasonSelect.value === '其他 / Other') {
            customReasonGroup.style.display = 'block';
            customReasonInput.required = true;
        } else {
            customReasonGroup.style.display = 'none';
            customReasonInput.required = false;
        }
    }

    async function confirmDelete(event) {
        event.preventDefault();

        const reasonSelect = document.getElementById('delete-reason');
        const customReason = document.getElementById('custom-reason').value;
        const checkoutRecord = document.getElementById('checkout-record').value;

        // Get final reason
        let reason = reasonSelect.value;
        if (reason === '其他 / Other' && customReason) {
            reason = customReason;
        }

        try {
            let successCount = 0;
            let errorCount = 0;

            for (const item of itemsToDelete) {
                try {
                    await fetchAPI(`/inventory/items/${item.id}`, {
                        method: 'DELETE',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            reason: reason,
                            checkout_record: checkoutRecord
                        })
                    });
                    successCount++;
                } catch (error) {
                    console.error(`Error deleting item ${item.id}:`, error);
                    errorCount++;
                }
            }

            closeDeleteModal();

            if (successCount > 0) {
                showMessage(`成功删除 ${successCount} 件物品 / Successfully deleted ${successCount} item(s)`, 'success');
            }
            if (errorCount > 0) {
                showMessage(`删除失败 ${errorCount} 件 / Failed to delete ${errorCount} item(s)`, 'error');
            }

            await loadInventory();

            // Reset checkboxes and button state after reload
            setTimeout(() => {
                const selectAll = document.getElementById('select-all');
                if (selectAll) selectAll.checked = false;

                const checkboxes = document.querySelectorAll('.item-checkbox');
                checkboxes.forEach(cb => cb.checked = false);

                updateSelectedCount();
            }, 100);
        } catch (error) {
            console.error('Error deleting items:', error);
            showMessage('删除物品时出错 / Error deleting items', 'error');
        }
    }

    // Load inventory on page load
    document.addEventListener('DOMContentLoaded', () => {
        loadInventory();

        // Note: Autocomplete will be initialized when modal is first opened
        // See showAddModal() function

        // Add Enter key support for search
        const searchInput = document.getElementById('search-input');
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchItems();
            }
        });

        // Auto-trigger search on dropdown changes
        document.getElementById('category-filter').addEventListener('change', searchItems);
        document.getElementById('expiry-filter').addEventListener('change', searchItems);

        // Check if we should open add item modal or edit item modal
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('action') === 'add') {
            showAddModal();
            // Remove the query parameter from URL without refreshing
            window.history.replaceState({}, document.title, window.location.pathname);
        } else if (urlParams.get('edit')) {
            const itemId = parseInt(urlParams.get('edit'));
            if (itemId) {
                // Wait for items to load, then open edit modal
                setTimeout(() => editItem(itemId), 500);
                // Remove the query parameter from URL without refreshing
                window.history.replaceState({}, document.title, window.location.pathname);
            }
        }
    });

    /**
     * Initialize autocomplete for Add Item form fields
     */
    function initializeAutocomplete() {
        // Initialize autocomplete for Category field
        initAutocomplete('item-category', 'category', {
            minChars: 0,
            maxSuggestions: 10,
            debounceMs: 150
        });

        // Initialize autocomplete for Location Path field
        initAutocomplete('item-location', 'location_path', {
            minChars: 0,
            maxSuggestions: 10,
            debounceMs: 150
        });

        // Initialize autocomplete for Unit field
        initAutocomplete('item-unit', 'unit', {
            minChars: 0,
            maxSuggestions: 8,
            debounceMs: 100
        });
    }

    // Close modals on escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeModal();
            closeDeleteModal();
        }
    });
</script>

<!-- Autocomplete functionality -->
<script src="/static/js/autocomplete.js"></script>

<style>
    /* Hide Actions column by default */
    .table th.actions-column,
    .table td.action-buttons {
        display: none;
        white-space: nowrap;
        padding: 0.75rem;
    }

    /* Show Actions column when hovering over the table */
    .table:hover th.actions-column,
    .table:hover td.action-buttons {
        display: table-cell;
    }

    /* Hide button content by default but keep the cell interactive */
    .action-buttons .btn {
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.15s ease;
    }

    /* Show buttons when hovering over the entire row */
    .hoverable-row:hover .action-buttons .btn {
        opacity: 1;
        pointer-events: auto;
    }

    /* Smooth row hover effect */
    .hoverable-row {
        transition: background-color 0.2s ease;
    }

    .hoverable-row:hover {
        background-color: rgba(59, 130, 246, 0.05) !important;
    }

    /* Button hover effect */
    .action-buttons .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
</style>

{% endblock %}
